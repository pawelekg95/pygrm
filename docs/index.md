# Module `app.github`

## Sub-modules

`[app.github.client](client.html "app.github.client")`

    

Github client module.

`[app.github.data](data/index.html "app.github.data")`

    

# Index

  * ### Super-module

    * `[app](../index.html "app")`
  * ### Sub-modules

    * `[app.github.client](client.html "app.github.client")`
    * `[app.github.data](data/index.html "app.github.data")`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.github.data.runner`

Runner module

Expand source code

    
    
    """
    Runner module
    """
    
    
    class Runner:  # pylint: disable=too-few-public-methods,too-many-instance-attributes
        """
        Runner class
        """
        def __init__(self,  # pylint: disable=too-many-arguments
                     name: str = '',
                     repository: str = '',
                     system: str = '',
                     arch: str = '',
                     online: bool = False,
                     as_docker: bool = False,
                     docker_enabled: bool = False,
                     docker_container_id: str = ''):
            """
            Constructor
            :param name:
            :param repository:
            :param system:
            :param arch:
            :param online:
            :param as_docker:
            :param docker_enabled:
            :param docker_container_id:
            """
            self.name = name
            self.repository = repository
            self.system = system
            self.arch = arch
            self.online = online
            self.as_docker = as_docker
            self.docker_enabled = docker_enabled
            self.docker_container_id = docker_container_id

## Classes

` class Runner (name: str = '', repository: str = '', system: str = '', arch:
str = '', online: bool = False, as_docker: bool = False, docker_enabled: bool
= False, docker_container_id: str = '') `

    

Runner class

Constructor :param name: :param repository: :param system: :param arch: :param
online: :param as_docker: :param docker_enabled: :param docker_container_id:

Expand source code

    
    
    class Runner:  # pylint: disable=too-few-public-methods,too-many-instance-attributes
        """
        Runner class
        """
        def __init__(self,  # pylint: disable=too-many-arguments
                     name: str = '',
                     repository: str = '',
                     system: str = '',
                     arch: str = '',
                     online: bool = False,
                     as_docker: bool = False,
                     docker_enabled: bool = False,
                     docker_container_id: str = ''):
            """
            Constructor
            :param name:
            :param repository:
            :param system:
            :param arch:
            :param online:
            :param as_docker:
            :param docker_enabled:
            :param docker_container_id:
            """
            self.name = name
            self.repository = repository
            self.system = system
            self.arch = arch
            self.online = online
            self.as_docker = as_docker
            self.docker_enabled = docker_enabled
            self.docker_container_id = docker_container_id

# Index

  * ### Super-module

    * `[app.github.data](index.html "app.github.data")`
  * ### Classes

    * #### `Runner`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.github.data`

## Sub-modules

`[app.github.data.repository](repository.html "app.github.data.repository")`

    

Repository module

`[app.github.data.runner](runner.html "app.github.data.runner")`

    

Runner module

# Index

  * ### Super-module

    * `[app.github](../index.html "app.github")`
  * ### Sub-modules

    * `[app.github.data.repository](repository.html "app.github.data.repository")`
    * `[app.github.data.runner](runner.html "app.github.data.runner")`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.github.data.repository`

Repository module

Expand source code

    
    
    """
    Repository module
    """
    
    
    class Repository:  # pylint: disable=too-few-public-methods
        """
        Repository class
        """
        def __init__(self, name: str = ''):
            """
            Constructor
            :param name:
            """
            self.name = name

## Classes

` class Repository (name: str = '') `

    

Repository class

Constructor :param name:

Expand source code

    
    
    class Repository:  # pylint: disable=too-few-public-methods
        """
        Repository class
        """
        def __init__(self, name: str = ''):
            """
            Constructor
            :param name:
            """
            self.name = name

# Index

  * ### Super-module

    * `[app.github.data](index.html "app.github.data")`
  * ### Classes

    * #### `Repository`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.github.client`

Github client module.

Expand source code

    
    
    """
    Github client module.
    """
    import json
    from typing import List, Tuple
    import requests
    
    from app.github.data.repository import Repository
    from app.github.data.runner import Runner
    from app.error.error import Error
    
    
    ARCHS_LABELS = ['X64', 'ARM64', 'ARM']
    SERVICE_LABELS = ['docker_service', 'shell_service']
    
    
    def _parse_repositories(repository_json: str = '')\
            -> Tuple[Error, List[Repository]]:
        """
        Parses response from github api repositories request
        :param repository_json:
        :return:
        """
        try:
            parsed_json = json.loads(repository_json)
        except json.JSONDecodeError:
            return Error.PARSE_ERROR, []
        token = []
        for repository_object in parsed_json:
            try:
                token.append(Repository(repository_object['name']))
            except KeyError:
                return Error.PARSE_ERROR, token
        return Error.OK, token
    
    
    def _parse_runners(runners_json: str = '', repository: str = '')\
            -> Tuple[Error, List[Runner]]:
        """
        Parses response from github api runners request
        :param runners_json:
        :param repository:
        :return:
        """
        try:
            parsed_json = json.loads(runners_json)
        except json.JSONDecodeError:
            return Error.PARSE_ERROR, []
        token = []
        for runner_object in parsed_json["runners"]:
            try:
                arch = ''
                service_type = ''
                for label in runner_object['labels']:
                    if label['name'] in ARCHS_LABELS:
                        arch = label['name']
                    elif label['name'] in SERVICE_LABELS:
                        service_type = label['name']
                token.append(Runner(name=runner_object['name'],
                                    system=runner_object["os"],
                                    arch=arch,
                                    online=runner_object['status'] == 'online',
                                    repository=repository,
                                    as_docker=service_type == SERVICE_LABELS[0]))
            except KeyError:
                return Error.PARSE_ERROR, token
        return Error.OK, token
    
    
    def _parse_token(token_json: str = '')\
            -> Tuple[Error, str]:
        """
        Parses github api token request
        :param token_json:
        :return:
        """
        try:
            parsed_json = json.loads(token_json)
        except json.JSONDecodeError:
            return Error.PARSE_ERROR, ''
        return Error.OK, parsed_json['token']
    
    
    class Client:
        """
        Github api client.
        """
        def __init__(self, user: str = '', auth_token: str = ''):
            """
            Constructor
            :param user:
            :param auth_token:
            """
            self.base_url = 'https://api.github.com'
            self.user = user
            self.auth_token = auth_token
            self.auth_header = {'Authorization': 'Bearer ' + self.auth_token}
            self.json_header = {'Accept': 'application/vnd.github+json'}
            self.content_header = {'Content-type': 'application/json'}
    
        def get_repositories(self) -> Tuple[Error, List[Repository]]:
            """
            Get user repositories
            :return:
            """
            repository_request = requests.get(self.base_url + '/user/repos',
                                              headers={**self.json_header,
                                                       **self.auth_header,
                                                       **self.content_header})
            if repository_request.status_code != 200:
                return Error.HTTP_ERROR, []
            return _parse_repositories(repository_request.text)
    
        def get_runners(self, repository: str = '') -> Tuple[Error, List[Runner]]:
            """
            Get self-hosted runners for repository
            :param repository:
            :return:
            """
            if not repository:
                return Error.EMPTY, []
            runners_request = requests.get(self.base_url + '/repos/' +
                                           self.user + '/' + repository +
                                           '/actions/runners',
                                           headers={**self.json_header,
                                                    **self.auth_header,
                                                    **self.content_header})
            if runners_request.status_code != 200:
                return Error.HTTP_ERROR, []
            return _parse_runners(runners_request.text, repository)
    
        def registration_token(self, repository: str = '') -> Tuple[Error, str]:
            """
            Get self-hosted github runner registration token
            :param repository:
            :return:
            """
            token_request = requests.post(self.base_url + '/repos/' +
                                          self.user + '/' + repository +
                                          '/actions/runners/registration-token',
                                          headers={**self.json_header,
                                                   **self.auth_header,
                                                   **self.content_header})
            if token_request.status_code != 201:
                return Error.HTTP_ERROR, ''
            return _parse_token(token_request.text)

## Classes

` class Client (user: str = '', auth_token: str = '') `

    

Github api client.

Constructor :param user: :param auth_token:

Expand source code

    
    
    class Client:
        """
        Github api client.
        """
        def __init__(self, user: str = '', auth_token: str = ''):
            """
            Constructor
            :param user:
            :param auth_token:
            """
            self.base_url = 'https://api.github.com'
            self.user = user
            self.auth_token = auth_token
            self.auth_header = {'Authorization': 'Bearer ' + self.auth_token}
            self.json_header = {'Accept': 'application/vnd.github+json'}
            self.content_header = {'Content-type': 'application/json'}
    
        def get_repositories(self) -> Tuple[Error, List[Repository]]:
            """
            Get user repositories
            :return:
            """
            repository_request = requests.get(self.base_url + '/user/repos',
                                              headers={**self.json_header,
                                                       **self.auth_header,
                                                       **self.content_header})
            if repository_request.status_code != 200:
                return Error.HTTP_ERROR, []
            return _parse_repositories(repository_request.text)
    
        def get_runners(self, repository: str = '') -> Tuple[Error, List[Runner]]:
            """
            Get self-hosted runners for repository
            :param repository:
            :return:
            """
            if not repository:
                return Error.EMPTY, []
            runners_request = requests.get(self.base_url + '/repos/' +
                                           self.user + '/' + repository +
                                           '/actions/runners',
                                           headers={**self.json_header,
                                                    **self.auth_header,
                                                    **self.content_header})
            if runners_request.status_code != 200:
                return Error.HTTP_ERROR, []
            return _parse_runners(runners_request.text, repository)
    
        def registration_token(self, repository: str = '') -> Tuple[Error, str]:
            """
            Get self-hosted github runner registration token
            :param repository:
            :return:
            """
            token_request = requests.post(self.base_url + '/repos/' +
                                          self.user + '/' + repository +
                                          '/actions/runners/registration-token',
                                          headers={**self.json_header,
                                                   **self.auth_header,
                                                   **self.content_header})
            if token_request.status_code != 201:
                return Error.HTTP_ERROR, ''
            return _parse_token(token_request.text)

### Methods

` def get_repositories(self) ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"),
List[[Repository](data/repository.html#app.github.data.repository.Repository
"app.github.data.repository.Repository")]] `

    

Get user repositories :return:

Expand source code

    
    
    def get_repositories(self) -> Tuple[Error, List[Repository]]:
        """
        Get user repositories
        :return:
        """
        repository_request = requests.get(self.base_url + '/user/repos',
                                          headers={**self.json_header,
                                                   **self.auth_header,
                                                   **self.content_header})
        if repository_request.status_code != 200:
            return Error.HTTP_ERROR, []
        return _parse_repositories(repository_request.text)

` def get_runners(self, repository: str = '') ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"),
List[[Runner](data/runner.html#app.github.data.runner.Runner
"app.github.data.runner.Runner")]] `

    

Get self-hosted runners for repository :param repository: :return:

Expand source code

    
    
    def get_runners(self, repository: str = '') -> Tuple[Error, List[Runner]]:
        """
        Get self-hosted runners for repository
        :param repository:
        :return:
        """
        if not repository:
            return Error.EMPTY, []
        runners_request = requests.get(self.base_url + '/repos/' +
                                       self.user + '/' + repository +
                                       '/actions/runners',
                                       headers={**self.json_header,
                                                **self.auth_header,
                                                **self.content_header})
        if runners_request.status_code != 200:
            return Error.HTTP_ERROR, []
        return _parse_runners(runners_request.text, repository)

` def registration_token(self, repository: str = '') ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str] `

    

Get self-hosted github runner registration token :param repository: :return:

Expand source code

    
    
    def registration_token(self, repository: str = '') -> Tuple[Error, str]:
        """
        Get self-hosted github runner registration token
        :param repository:
        :return:
        """
        token_request = requests.post(self.base_url + '/repos/' +
                                      self.user + '/' + repository +
                                      '/actions/runners/registration-token',
                                      headers={**self.json_header,
                                               **self.auth_header,
                                               **self.content_header})
        if token_request.status_code != 201:
            return Error.HTTP_ERROR, ''
        return _parse_token(token_request.text)

# Index

  * ### Super-module

    * `[app.github](index.html "app.github")`
  * ### Classes

    * #### `Client`

      * `get_repositories`
      * `get_runners`
      * `registration_token`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.terminal.interface`

Command line interface module

Expand source code

    
    
    """ Command line interface module """
    from typing import Callable, List
    from app.error.error import Error, message
    from app.github.client import Client as GithubClient
    from .commands import install_runner, remove_runner, stop_runner, start_runner, list_runners
    
    
    class Command:  # pylint: disable=too-few-public-methods
        """
        Command abstraction class. Contains callable function and its' description
        """
        def __init__(self,
                     description: str = '', command: Callable[[GithubClient, List[str]], Error] = None):
            self.description = description
            self.command = command
    
    
    class Interface:
        """
        Interface class
        """
        def __init__(self, github_client: GithubClient = None):
            """
            Constructor
            :param github_client: Initialized Github client to be used
            """
            self.running = True
            self.github_client = github_client
            error_code, self.repositories = github_client.get_repositories()
            if error_code != Error.OK:
                raise ConnectionError
            self.option_mapping = {
                'install': Command('Install new GitHub runner', install_runner.perform),
                'remove':  Command('Remove GitHub runner', remove_runner.perform),
                'stop': Command('Stop GitHub runner', stop_runner.perform),
                'start': Command('Start GitHub runner', start_runner.perform),
                'exit': Command('Quit PyGrm', self.stop),
                'help': Command('Print help', self.print_description),
                'runners': Command('List all runners', list_runners.perform),
                'repositories': Command('List repositories', self.list_repositories)
            }
    
            self.loop()
    
        def list_repositories(self, *_):
            """
            Lists all repositories of user
            :param _:
            :return:
            """
            for repository in self.repositories:
                print(repository.name)
            return Error.OK
    
        def print_description(self, *_):
            """
            Prints description
            :param _:
            :return:
            """
            print('== PyGrm ==')
            for command_key, command in self.option_mapping.items():
                print(command_key, ' - ', command.description)
            return Error.OK
    
        def stop(self, *_):
            """
            Stop pygrm
            :param _:
            :return:
            """
            print('Stopping PyGrm')
            self.running = False
            return Error.OK
    
        def loop(self):
            """
            Main loop
            :return:
            """
            self.print_description()
            while self.running:
                option = input('>>> ')
                if option not in self.option_mapping.keys():  # pylint: disable=consider-iterating-dictionary
                    continue
                error_code = self.option_mapping[option].command(
                    self.github_client, self.repositories)
                if error_code != Error.OK:
                    print('Command failed, error=' + message(error_code))

## Classes

` class Command (description: str = '', command:
Callable[[[Client](../github/client.html#app.github.client.Client
"app.github.client.Client"), List[str]],
[Error](../error/error.html#app.error.error.Error "app.error.error.Error")] =
None) `

    

Command abstraction class. Contains callable function and its' description

Expand source code

    
    
    class Command:  # pylint: disable=too-few-public-methods
        """
        Command abstraction class. Contains callable function and its' description
        """
        def __init__(self,
                     description: str = '', command: Callable[[GithubClient, List[str]], Error] = None):
            self.description = description
            self.command = command

` class Interface (github_client:
[Client](../github/client.html#app.github.client.Client
"app.github.client.Client") = None) `

    

Interface class

Constructor :param github_client: Initialized Github client to be used

Expand source code

    
    
    class Interface:
        """
        Interface class
        """
        def __init__(self, github_client: GithubClient = None):
            """
            Constructor
            :param github_client: Initialized Github client to be used
            """
            self.running = True
            self.github_client = github_client
            error_code, self.repositories = github_client.get_repositories()
            if error_code != Error.OK:
                raise ConnectionError
            self.option_mapping = {
                'install': Command('Install new GitHub runner', install_runner.perform),
                'remove':  Command('Remove GitHub runner', remove_runner.perform),
                'stop': Command('Stop GitHub runner', stop_runner.perform),
                'start': Command('Start GitHub runner', start_runner.perform),
                'exit': Command('Quit PyGrm', self.stop),
                'help': Command('Print help', self.print_description),
                'runners': Command('List all runners', list_runners.perform),
                'repositories': Command('List repositories', self.list_repositories)
            }
    
            self.loop()
    
        def list_repositories(self, *_):
            """
            Lists all repositories of user
            :param _:
            :return:
            """
            for repository in self.repositories:
                print(repository.name)
            return Error.OK
    
        def print_description(self, *_):
            """
            Prints description
            :param _:
            :return:
            """
            print('== PyGrm ==')
            for command_key, command in self.option_mapping.items():
                print(command_key, ' - ', command.description)
            return Error.OK
    
        def stop(self, *_):
            """
            Stop pygrm
            :param _:
            :return:
            """
            print('Stopping PyGrm')
            self.running = False
            return Error.OK
    
        def loop(self):
            """
            Main loop
            :return:
            """
            self.print_description()
            while self.running:
                option = input('>>> ')
                if option not in self.option_mapping.keys():  # pylint: disable=consider-iterating-dictionary
                    continue
                error_code = self.option_mapping[option].command(
                    self.github_client, self.repositories)
                if error_code != Error.OK:
                    print('Command failed, error=' + message(error_code))

### Methods

` def list_repositories(self, *_) `

    

Lists all repositories of user :param _: :return:

Expand source code

    
    
    def list_repositories(self, *_):
        """
        Lists all repositories of user
        :param _:
        :return:
        """
        for repository in self.repositories:
            print(repository.name)
        return Error.OK

` def loop(self) `

    

Main loop :return:

Expand source code

    
    
    def loop(self):
        """
        Main loop
        :return:
        """
        self.print_description()
        while self.running:
            option = input('>>> ')
            if option not in self.option_mapping.keys():  # pylint: disable=consider-iterating-dictionary
                continue
            error_code = self.option_mapping[option].command(
                self.github_client, self.repositories)
            if error_code != Error.OK:
                print('Command failed, error=' + message(error_code))

` def print_description(self, *_) `

    

Prints description :param _: :return:

Expand source code

    
    
    def print_description(self, *_):
        """
        Prints description
        :param _:
        :return:
        """
        print('== PyGrm ==')
        for command_key, command in self.option_mapping.items():
            print(command_key, ' - ', command.description)
        return Error.OK

` def stop(self, *_) `

    

Stop pygrm :param _: :return:

Expand source code

    
    
    def stop(self, *_):
        """
        Stop pygrm
        :param _:
        :return:
        """
        print('Stopping PyGrm')
        self.running = False
        return Error.OK

# Index

  * ### Super-module

    * `[app.terminal](index.html "app.terminal")`
  * ### Classes

    * #### `Command`

    * #### `Interface`

      * `list_repositories`
      * `loop`
      * `print_description`
      * `stop`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.terminal`

## Sub-modules

`[app.terminal.commands](commands/index.html "app.terminal.commands")`

    

`[app.terminal.interface](interface.html "app.terminal.interface")`

    

Command line interface module

# Index

  * ### Super-module

    * `[app](../index.html "app")`
  * ### Sub-modules

    * `[app.terminal.commands](commands/index.html "app.terminal.commands")`
    * `[app.terminal.interface](interface.html "app.terminal.interface")`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.terminal.commands.remove_runner`

Remove runner command module

Expand source code

    
    
    """ Remove runner command module """
    from app.error.error import Error
    
    
    def perform(*_) -> Error:
        """
        :param _:
        :return:
        """
        return Error.OK

## Functions

` def perform(*_) ‑> [Error](../../error/error.html#app.error.error.Error
"app.error.error.Error") `

    

:param _: :return:

Expand source code

    
    
    def perform(*_) -> Error:
        """
        :param _:
        :return:
        """
        return Error.OK

# Index

  * ### Super-module

    * `[app.terminal.commands](index.html "app.terminal.commands")`
  * ### Functions

    * `perform`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.terminal.commands.strategies`

## Sub-modules

`[app.terminal.commands.strategies.install_docker_strategy](install_docker_strategy.html
"app.terminal.commands.strategies.install_docker_strategy")`

    

Install docker runner strategy

`[app.terminal.commands.strategies.install_shell_strategy](install_shell_strategy.html
"app.terminal.commands.strategies.install_shell_strategy")`

    

Install shell github runner strategy

# Index

  * ### Super-module

    * `[app.terminal.commands](../index.html "app.terminal.commands")`
  * ### Sub-modules

    * `[app.terminal.commands.strategies.install_docker_strategy](install_docker_strategy.html "app.terminal.commands.strategies.install_docker_strategy")`
    * `[app.terminal.commands.strategies.install_shell_strategy](install_shell_strategy.html "app.terminal.commands.strategies.install_shell_strategy")`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.terminal.commands.strategies.install_docker_strategy`

Install docker runner strategy

Expand source code

    
    
    """
    Install docker runner strategy
    """
    import os
    from typing import Union
    from app.error.error import Error
    from app.github.client import Client as GithubClient
    from app.device.local import LocalClient
    from app.device.remote import RemoteClient
    
    
    class DockerStrategy:  # pylint: disable=too-few-public-methods
        """
        Strategy for installing github runner inside docker container
        """
        def __init__(self,
                     device_manager: Union[LocalClient, RemoteClient] = None,
                     github_client: GithubClient = None):
            """
            Constructor
            :param device_manager:
            :param github_client:
            """
            self.device_manager = device_manager
            self.github_client = github_client
    
        def install(self,
                    repo_name: str = '',
                    runner_name: str = '') -> Error:
            """
            Performs installation
            :param repo_name:
            :param runner_name:
            :return:
            """
            image_path = \
                os.path.dirname(os.path.dirname(
                    os.path.dirname(os.path.dirname(
                        os.path.dirname(os.path.abspath(__file__)))))) + \
                '/images/github-runner.dockerfile'
            error_code, token = self.github_client.registration_token(repo_name)
            if error_code != Error.OK:
                return error_code
            error_code, stdout, stderr = self.device_manager.build_docker_image(
                image_path,
                self.github_client.user,
                token,
                repo_name,
                repo_name + '_' + runner_name)
            print(stdout, '\n', stderr)
            return error_code

## Classes

` class DockerStrategy (device_manager:
Union[[LocalClient](../../../device/local.html#app.device.local.LocalClient
"app.device.local.LocalClient"),
[RemoteClient](../../../device/remote.html#app.device.remote.RemoteClient
"app.device.remote.RemoteClient")] = None, github_client:
[Client](../../../github/client.html#app.github.client.Client
"app.github.client.Client") = None) `

    

Strategy for installing github runner inside docker container

Constructor :param device_manager: :param github_client:

Expand source code

    
    
    class DockerStrategy:  # pylint: disable=too-few-public-methods
        """
        Strategy for installing github runner inside docker container
        """
        def __init__(self,
                     device_manager: Union[LocalClient, RemoteClient] = None,
                     github_client: GithubClient = None):
            """
            Constructor
            :param device_manager:
            :param github_client:
            """
            self.device_manager = device_manager
            self.github_client = github_client
    
        def install(self,
                    repo_name: str = '',
                    runner_name: str = '') -> Error:
            """
            Performs installation
            :param repo_name:
            :param runner_name:
            :return:
            """
            image_path = \
                os.path.dirname(os.path.dirname(
                    os.path.dirname(os.path.dirname(
                        os.path.dirname(os.path.abspath(__file__)))))) + \
                '/images/github-runner.dockerfile'
            error_code, token = self.github_client.registration_token(repo_name)
            if error_code != Error.OK:
                return error_code
            error_code, stdout, stderr = self.device_manager.build_docker_image(
                image_path,
                self.github_client.user,
                token,
                repo_name,
                repo_name + '_' + runner_name)
            print(stdout, '\n', stderr)
            return error_code

### Methods

` def install(self, repo_name: str = '', runner_name: str = '') ‑>
[Error](../../../error/error.html#app.error.error.Error
"app.error.error.Error") `

    

Performs installation :param repo_name: :param runner_name: :return:

Expand source code

    
    
    def install(self,
                repo_name: str = '',
                runner_name: str = '') -> Error:
        """
        Performs installation
        :param repo_name:
        :param runner_name:
        :return:
        """
        image_path = \
            os.path.dirname(os.path.dirname(
                os.path.dirname(os.path.dirname(
                    os.path.dirname(os.path.abspath(__file__)))))) + \
            '/images/github-runner.dockerfile'
        error_code, token = self.github_client.registration_token(repo_name)
        if error_code != Error.OK:
            return error_code
        error_code, stdout, stderr = self.device_manager.build_docker_image(
            image_path,
            self.github_client.user,
            token,
            repo_name,
            repo_name + '_' + runner_name)
        print(stdout, '\n', stderr)
        return error_code

# Index

  * ### Super-module

    * `[app.terminal.commands.strategies](index.html "app.terminal.commands.strategies")`
  * ### Classes

    * #### `DockerStrategy`

      * `install`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.terminal.commands.strategies.install_shell_strategy`

Install shell github runner strategy

Expand source code

    
    
    """
    Install shell github runner strategy
    """
    from typing import Union
    from app.error.error import Error
    from app.github.client import Client as GithubClient
    from app.device.local import LocalClient
    from app.device.remote import RemoteClient
    
    
    class ShellStrategy:  # pylint: disable=too-few-public-methods
        """
        Shell strategy
        """
        def __init__(self,
                     device_manager: Union[LocalClient, RemoteClient] = None,
                     github_client: GithubClient = None):
            """
            Constructor
            :param device_manager:
            :param github_client:
            """
            self.device_manager = device_manager
            self.github_client = github_client
    
        def install(self,
                    repo_name: str = '',
                    runner_name: str = '') -> Error:
            """
            Perform installation
            :param repo_name:
            :param runner_name:
            :return:
            """
            error_code, token = self.github_client.registration_token(repo_name)
            if error_code != Error.OK:
                return error_code
            error_code, stdout, stderr = self.device_manager.install_github_service(
                self.github_client.user,
                token,
                repo_name,
                repo_name + '_' + runner_name)
            print(stdout, '\n', stderr)
            return error_code

## Classes

` class ShellStrategy (device_manager:
Union[[LocalClient](../../../device/local.html#app.device.local.LocalClient
"app.device.local.LocalClient"),
[RemoteClient](../../../device/remote.html#app.device.remote.RemoteClient
"app.device.remote.RemoteClient")] = None, github_client:
[Client](../../../github/client.html#app.github.client.Client
"app.github.client.Client") = None) `

    

Shell strategy

Constructor :param device_manager: :param github_client:

Expand source code

    
    
    class ShellStrategy:  # pylint: disable=too-few-public-methods
        """
        Shell strategy
        """
        def __init__(self,
                     device_manager: Union[LocalClient, RemoteClient] = None,
                     github_client: GithubClient = None):
            """
            Constructor
            :param device_manager:
            :param github_client:
            """
            self.device_manager = device_manager
            self.github_client = github_client
    
        def install(self,
                    repo_name: str = '',
                    runner_name: str = '') -> Error:
            """
            Perform installation
            :param repo_name:
            :param runner_name:
            :return:
            """
            error_code, token = self.github_client.registration_token(repo_name)
            if error_code != Error.OK:
                return error_code
            error_code, stdout, stderr = self.device_manager.install_github_service(
                self.github_client.user,
                token,
                repo_name,
                repo_name + '_' + runner_name)
            print(stdout, '\n', stderr)
            return error_code

### Methods

` def install(self, repo_name: str = '', runner_name: str = '') ‑>
[Error](../../../error/error.html#app.error.error.Error
"app.error.error.Error") `

    

Perform installation :param repo_name: :param runner_name: :return:

Expand source code

    
    
    def install(self,
                repo_name: str = '',
                runner_name: str = '') -> Error:
        """
        Perform installation
        :param repo_name:
        :param runner_name:
        :return:
        """
        error_code, token = self.github_client.registration_token(repo_name)
        if error_code != Error.OK:
            return error_code
        error_code, stdout, stderr = self.device_manager.install_github_service(
            self.github_client.user,
            token,
            repo_name,
            repo_name + '_' + runner_name)
        print(stdout, '\n', stderr)
        return error_code

# Index

  * ### Super-module

    * `[app.terminal.commands.strategies](index.html "app.terminal.commands.strategies")`
  * ### Classes

    * #### `ShellStrategy`

      * `install`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.terminal.commands.start_runner`

Start runner command module

Expand source code

    
    
    """ Start runner command module """
    from getpass import getpass
    from typing import List
    from app.device.local import LocalClient
    from app.device.remote import RemoteClient
    from app.error.error import Error
    
    
    def perform(_, repositories: List[str] = None) -> Error:
        """
        Start runner command
        :param _:
        :param repositories:
        :return:
        """
        if not repositories:
            print('No repositories')
        repo_name = input('For what repository? ')
        if repo_name not in [x.name for x in repositories]:
            print('No such repository. '
                  'Run "repositories" command to list available projects')
            return Error.EMPTY
        runner_name = input('Runner name: ')
        destination = input('Install runner locally on remote host? [local / remote] ')
        if destination not in ['local', 'remote']:
            print('Wrong option')
            return Error.VALUE_ERROR
        if destination == 'local':
            device_manager = LocalClient()
        else:
            host = input('Host: ')
            user = input('User: ')
            password = getpass()
            device_manager = RemoteClient(host=host, user=user, password=password)
        runner_type = input('What type of runner? [shell / docker] ')
        if runner_type not in ['shell', 'docker']:
            return Error.VALUE_ERROR
        return device_manager.start_container(repo_name + '_' + runner_name)[0]\
            if runner_type == 'docker'\
            else device_manager.start_github_service(repo_name + '_' + runner_name)[0]

## Functions

` def perform(_, repositories: List[str] = None) ‑>
[Error](../../error/error.html#app.error.error.Error "app.error.error.Error")
`

    

Start runner command :param _: :param repositories: :return:

Expand source code

    
    
    def perform(_, repositories: List[str] = None) -> Error:
        """
        Start runner command
        :param _:
        :param repositories:
        :return:
        """
        if not repositories:
            print('No repositories')
        repo_name = input('For what repository? ')
        if repo_name not in [x.name for x in repositories]:
            print('No such repository. '
                  'Run "repositories" command to list available projects')
            return Error.EMPTY
        runner_name = input('Runner name: ')
        destination = input('Install runner locally on remote host? [local / remote] ')
        if destination not in ['local', 'remote']:
            print('Wrong option')
            return Error.VALUE_ERROR
        if destination == 'local':
            device_manager = LocalClient()
        else:
            host = input('Host: ')
            user = input('User: ')
            password = getpass()
            device_manager = RemoteClient(host=host, user=user, password=password)
        runner_type = input('What type of runner? [shell / docker] ')
        if runner_type not in ['shell', 'docker']:
            return Error.VALUE_ERROR
        return device_manager.start_container(repo_name + '_' + runner_name)[0]\
            if runner_type == 'docker'\
            else device_manager.start_github_service(repo_name + '_' + runner_name)[0]

# Index

  * ### Super-module

    * `[app.terminal.commands](index.html "app.terminal.commands")`
  * ### Functions

    * `perform`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.terminal.commands.list_runners`

List runner command module

Expand source code

    
    
    """ List runner command module """
    from typing import List
    from app.github.client import Client as GithubClient
    from app.error.error import Error
    
    
    def perform(github_client: GithubClient = None,
                repositories: List[str] = None) -> Error:
        """
        Lists runners
        :param github_client:
        :param repositories:
        :return:
        """
        if not repositories:
            print('No repositories')
        repo_name = input('For what repository? ')
        if repo_name not in [x.name for x in repositories]:
            print('No such repository')
            return Error.EMPTY
        error_code, runners = github_client.get_runners(repo_name)
        if error_code != Error.OK:
            print('Failed to get runners')
            return error_code
        if not runners:
            print('No runners registered for project')
        for runner in runners:
            print('Name:', runner.name, ', system:', runner.system,
                  ', architecture:', runner.arch, ', online:',
                  runner.online, ', repository:', runner.repository,
                  ', runs as docker service:', runner.as_docker,
                  ', docker enabled:', runner.docker_enabled, ', container id:',
                  runner.docker_container_id if runner.as_docker else 'None')
        return Error.OK

## Functions

` def perform(github_client:
[Client](../../github/client.html#app.github.client.Client
"app.github.client.Client") = None, repositories: List[str] = None) ‑>
[Error](../../error/error.html#app.error.error.Error "app.error.error.Error")
`

    

Lists runners :param github_client: :param repositories: :return:

Expand source code

    
    
    def perform(github_client: GithubClient = None,
                repositories: List[str] = None) -> Error:
        """
        Lists runners
        :param github_client:
        :param repositories:
        :return:
        """
        if not repositories:
            print('No repositories')
        repo_name = input('For what repository? ')
        if repo_name not in [x.name for x in repositories]:
            print('No such repository')
            return Error.EMPTY
        error_code, runners = github_client.get_runners(repo_name)
        if error_code != Error.OK:
            print('Failed to get runners')
            return error_code
        if not runners:
            print('No runners registered for project')
        for runner in runners:
            print('Name:', runner.name, ', system:', runner.system,
                  ', architecture:', runner.arch, ', online:',
                  runner.online, ', repository:', runner.repository,
                  ', runs as docker service:', runner.as_docker,
                  ', docker enabled:', runner.docker_enabled, ', container id:',
                  runner.docker_container_id if runner.as_docker else 'None')
        return Error.OK

# Index

  * ### Super-module

    * `[app.terminal.commands](index.html "app.terminal.commands")`
  * ### Functions

    * `perform`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.terminal.commands`

## Sub-modules

`[app.terminal.commands.additional_information](additional_information.html
"app.terminal.commands.additional_information")`

    

Module for querying additional information from user

`[app.terminal.commands.install_runner](install_runner.html
"app.terminal.commands.install_runner")`

    

Install runner command module

`[app.terminal.commands.list_runners](list_runners.html
"app.terminal.commands.list_runners")`

    

List runner command module

`[app.terminal.commands.remove_runner](remove_runner.html
"app.terminal.commands.remove_runner")`

    

Remove runner command module

`[app.terminal.commands.start_runner](start_runner.html
"app.terminal.commands.start_runner")`

    

Start runner command module

`[app.terminal.commands.stop_runner](stop_runner.html
"app.terminal.commands.stop_runner")`

    

Stop runner command module

`[app.terminal.commands.strategies](strategies/index.html
"app.terminal.commands.strategies")`

    

# Index

  * ### Super-module

    * `[app.terminal](../index.html "app.terminal")`
  * ### Sub-modules

    * `[app.terminal.commands.additional_information](additional_information.html "app.terminal.commands.additional_information")`
    * `[app.terminal.commands.install_runner](install_runner.html "app.terminal.commands.install_runner")`
    * `[app.terminal.commands.list_runners](list_runners.html "app.terminal.commands.list_runners")`
    * `[app.terminal.commands.remove_runner](remove_runner.html "app.terminal.commands.remove_runner")`
    * `[app.terminal.commands.start_runner](start_runner.html "app.terminal.commands.start_runner")`
    * `[app.terminal.commands.stop_runner](stop_runner.html "app.terminal.commands.stop_runner")`
    * `[app.terminal.commands.strategies](strategies/index.html "app.terminal.commands.strategies")`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.terminal.commands.stop_runner`

Stop runner command module

Expand source code

    
    
    """ Stop runner command module """
    from getpass import getpass
    from typing import List
    from app.device.local import LocalClient
    from app.device.remote import RemoteClient
    from app.error.error import Error
    
    
    def perform(_, repositories: List[str] = None) -> Error:
        """
        Stop runner
        :param _: Unused
        :param repositories:
        :return:
        """
        if not repositories:
            print('No repositories')
        repo_name = input('For what repository? ')
        if repo_name not in [x.name for x in repositories]:
            print('No such repository. Run "repositories" command to list available projects')
            return Error.EMPTY
        runner_name = input('Runner name: ')
        destination = input('Install runner locally on remote host? [local / remote] ')
        if destination not in ['local', 'remote']:
            print('Wrong option')
            return Error.VALUE_ERROR
        if destination == 'local':
            device_manager = LocalClient()
        else:
            host = input('Host: ')
            user = input('User: ')
            password = getpass()
            device_manager = RemoteClient(host=host, user=user, password=password)
        runner_type = input('What type of runner? [shell / docker] ')
        if runner_type not in ['shell', 'docker']:
            return Error.VALUE_ERROR
        return device_manager.stop_container(repo_name + '_' + runner_name)[0] \
            if runner_type == 'docker' \
            else device_manager.stop_github_service(repo_name + '_' + runner_name)[0]

## Functions

` def perform(_, repositories: List[str] = None) ‑>
[Error](../../error/error.html#app.error.error.Error "app.error.error.Error")
`

    

Stop runner :param _: Unused :param repositories: :return:

Expand source code

    
    
    def perform(_, repositories: List[str] = None) -> Error:
        """
        Stop runner
        :param _: Unused
        :param repositories:
        :return:
        """
        if not repositories:
            print('No repositories')
        repo_name = input('For what repository? ')
        if repo_name not in [x.name for x in repositories]:
            print('No such repository. Run "repositories" command to list available projects')
            return Error.EMPTY
        runner_name = input('Runner name: ')
        destination = input('Install runner locally on remote host? [local / remote] ')
        if destination not in ['local', 'remote']:
            print('Wrong option')
            return Error.VALUE_ERROR
        if destination == 'local':
            device_manager = LocalClient()
        else:
            host = input('Host: ')
            user = input('User: ')
            password = getpass()
            device_manager = RemoteClient(host=host, user=user, password=password)
        runner_type = input('What type of runner? [shell / docker] ')
        if runner_type not in ['shell', 'docker']:
            return Error.VALUE_ERROR
        return device_manager.stop_container(repo_name + '_' + runner_name)[0] \
            if runner_type == 'docker' \
            else device_manager.stop_github_service(repo_name + '_' + runner_name)[0]

# Index

  * ### Super-module

    * `[app.terminal.commands](index.html "app.terminal.commands")`
  * ### Functions

    * `perform`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.terminal.commands.additional_information`

Module for querying additional information from user

Expand source code

    
    
    """ Module for querying additional information from user """
    
    
    class AdditionalInfo:  # pylint: disable=too-few-public-methods
        """
        Additional information from user
        """
        def __init__(self):
            self.remote = False

## Classes

` class AdditionalInfo `

    

Additional information from user

Expand source code

    
    
    class AdditionalInfo:  # pylint: disable=too-few-public-methods
        """
        Additional information from user
        """
        def __init__(self):
            self.remote = False

# Index

  * ### Super-module

    * `[app.terminal.commands](index.html "app.terminal.commands")`
  * ### Classes

    * #### `AdditionalInfo`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.terminal.commands.install_runner`

Install runner command module

Expand source code

    
    
    """ Install runner command module """
    from getpass import getpass
    from typing import List
    from app.github.client import Client as GithubClient
    from app.error.error import Error
    from app.device.local import LocalClient
    from app.device.remote import RemoteClient
    from app.terminal.commands.strategies.install_shell_strategy import ShellStrategy
    from app.terminal.commands.strategies.install_docker_strategy import DockerStrategy
    
    
    DESTINATION = ['local', 'remote']
    TYPE = ['shell', 'docker']
    
    
    def perform(github_client: GithubClient = None,  # pylint: disable=too-many-return-statements
                repositories: List[str] = None) -> Error:
        """
        Installs new runner
        :param github_client:
        :param repositories:
        :return:
        """
        if not repositories:
            print('No repositories')
        repo_name = input('For what repository? ')
        if repo_name not in [x.name for x in repositories]:
            print('No such repository. Run "repositories" command to list available projects')
            return Error.EMPTY
        runner_name = input('Runner name: ')
        error_code, runners = github_client.get_runners(repo_name)
        if error_code != Error.OK:
            print('Failed to get runners')
            return error_code
        if repo_name + '_' + runner_name in [x.name for x in runners]:
            print('Runner with such name already exists.'
                  'Run "runners" command to list already registered runner')
            return Error.VALUE_ERROR
        destination =\
            input('Install runner locally on remote host? [local / remote] ')
        if destination not in DESTINATION:
            print('Wrong option')
            return Error.VALUE_ERROR
        if destination == 'local':
            device_manager = LocalClient()
        else:
            host = input('Host: ')
            user = input('User: ')
            password = getpass()
            device_manager = RemoteClient(host=host, user=user, password=password)
        runner_type = input('What type of runner? [shell / docker] ')
        if runner_type not in TYPE:
            return Error.VALUE_ERROR
        install_strategy = ShellStrategy(device_manager, github_client) if runner_type == TYPE[0] \
            else DockerStrategy(device_manager, github_client)
        error_code = install_strategy.install(repo_name, runner_name)
        if error_code != Error.OK:
            return error_code
        launch = input('Runner installed correctly.'
                       'Do you want to launch it immediately? [yes / no] ')
        if launch not in ['yes', 'no']:
            return Error.VALUE_ERROR
        if launch == 'no':
            return Error.OK
        return device_manager.start_container(repo_name + '_' + runner_name)[0]\
            if runner_type == 'docker'\
            else device_manager.start_github_service(repo_name + '_' + runner_name)[0]

## Functions

` def perform(github_client:
[Client](../../github/client.html#app.github.client.Client
"app.github.client.Client") = None, repositories: List[str] = None) ‑>
[Error](../../error/error.html#app.error.error.Error "app.error.error.Error")
`

    

Installs new runner :param github_client: :param repositories: :return:

Expand source code

    
    
    def perform(github_client: GithubClient = None,  # pylint: disable=too-many-return-statements
                repositories: List[str] = None) -> Error:
        """
        Installs new runner
        :param github_client:
        :param repositories:
        :return:
        """
        if not repositories:
            print('No repositories')
        repo_name = input('For what repository? ')
        if repo_name not in [x.name for x in repositories]:
            print('No such repository. Run "repositories" command to list available projects')
            return Error.EMPTY
        runner_name = input('Runner name: ')
        error_code, runners = github_client.get_runners(repo_name)
        if error_code != Error.OK:
            print('Failed to get runners')
            return error_code
        if repo_name + '_' + runner_name in [x.name for x in runners]:
            print('Runner with such name already exists.'
                  'Run "runners" command to list already registered runner')
            return Error.VALUE_ERROR
        destination =\
            input('Install runner locally on remote host? [local / remote] ')
        if destination not in DESTINATION:
            print('Wrong option')
            return Error.VALUE_ERROR
        if destination == 'local':
            device_manager = LocalClient()
        else:
            host = input('Host: ')
            user = input('User: ')
            password = getpass()
            device_manager = RemoteClient(host=host, user=user, password=password)
        runner_type = input('What type of runner? [shell / docker] ')
        if runner_type not in TYPE:
            return Error.VALUE_ERROR
        install_strategy = ShellStrategy(device_manager, github_client) if runner_type == TYPE[0] \
            else DockerStrategy(device_manager, github_client)
        error_code = install_strategy.install(repo_name, runner_name)
        if error_code != Error.OK:
            return error_code
        launch = input('Runner installed correctly.'
                       'Do you want to launch it immediately? [yes / no] ')
        if launch not in ['yes', 'no']:
            return Error.VALUE_ERROR
        if launch == 'no':
            return Error.OK
        return device_manager.start_container(repo_name + '_' + runner_name)[0]\
            if runner_type == 'docker'\
            else device_manager.start_github_service(repo_name + '_' + runner_name)[0]

# Index

  * ### Super-module

    * `[app.terminal.commands](index.html "app.terminal.commands")`
  * ### Functions

    * `perform`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Package `app`

## Sub-modules

`[app.device](device/index.html "app.device")`

    

`[app.error](error/index.html "app.error")`

    

`[app.github](github/index.html "app.github")`

    

`[app.pygrm](pygrm.html "app.pygrm")`

    

PyGrm utility to easily manage github self-hosted runners

`[app.terminal](terminal/index.html "app.terminal")`

    

# Index

  * ### Sub-modules

    * `[app.device](device/index.html "app.device")`
    * `[app.error](error/index.html "app.error")`
    * `[app.github](github/index.html "app.github")`
    * `[app.pygrm](pygrm.html "app.pygrm")`
    * `[app.terminal](terminal/index.html "app.terminal")`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.pygrm`

PyGrm utility to easily manage github self-hosted runners

Expand source code

    
    
    #!/bin/python3
    """ PyGrm utility to easily manage github self-hosted runners """
    
    import argparse
    from typing import List
    import sys
    import os
    
    SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
    sys.path.append(os.path.dirname(SCRIPT_DIR))
    
    from app.github.client import Client as GithubClient  # pylint: disable=wrong-import-position
    from app.terminal.interface import Interface  # pylint: disable=wrong-import-position
    
    
    def parse_arguments(argv: List[str] = None):
        """
        Parses arguments
        :param argv: System arguments passed to PyGrm to be parsed
        :return: Parsed arguments
        """
        parser = argparse.ArgumentParser(description='PyGrm. Python utility to manage github runners',
                                         formatter_class=argparse.RawTextHelpFormatter)
        parser.add_argument('-t', '--token', dest='token', help='Private GitHub token', required=True)
        parser.add_argument('-u', '--user', dest='user', help='GitHub user', required=True)
        return parser.parse_args(args=argv)
    
    
    if __name__ == "__main__":
        args = parse_arguments(sys.argv[1:])
        print('Fetching data...')
        github_client = GithubClient(user=args.user, auth_token=args.token)
        print('OK')
        interface = Interface(github_client)

## Functions

` def parse_arguments(argv: List[str] = None) `

    

Parses arguments :param argv: System arguments passed to PyGrm to be parsed
:return: Parsed arguments

Expand source code

    
    
    def parse_arguments(argv: List[str] = None):
        """
        Parses arguments
        :param argv: System arguments passed to PyGrm to be parsed
        :return: Parsed arguments
        """
        parser = argparse.ArgumentParser(description='PyGrm. Python utility to manage github runners',
                                         formatter_class=argparse.RawTextHelpFormatter)
        parser.add_argument('-t', '--token', dest='token', help='Private GitHub token', required=True)
        parser.add_argument('-u', '--user', dest='user', help='GitHub user', required=True)
        return parser.parse_args(args=argv)

# Index

  * ### Super-module

    * `[app](index.html "app")`
  * ### Functions

    * `parse_arguments`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.device`

## Sub-modules

`[app.device.local](local.html "app.device.local")`

    

Module that provides abstraction layer for local device

`[app.device.remote](remote.html "app.device.remote")`

    

Remote device module

# Index

  * ### Super-module

    * `[app](../index.html "app")`
  * ### Sub-modules

    * `[app.device.local](local.html "app.device.local")`
    * `[app.device.remote](remote.html "app.device.remote")`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.device.local`

Module that provides abstraction layer for local device

Expand source code

    
    
    """ Module that provides abstraction layer for local device """
    from typing import Tuple
    from app.error.error import Error
    
    
    class LocalClient:
        """
        Abstraction to represent local device
        """
    
        # @classmethod
        # def __container_running(cls, *_) -> bool:
        #     """
        #     Checks if docker container is already running
        #     :param image_name: Image name
        #     :return: True if docker container is running, False otherwise
        #     """
        #     return False
    
        @classmethod
        def build_docker_image(cls, *_) \
                -> Tuple[Error, str, str]:
            """
            Build docker image
            :param _:
            :return:
            """
            return Error.OK, '', ''
    
        @classmethod
        def start_container(cls, *_) -> Tuple[Error, str, str]:
            """
            Start docker container from image name
            :param _:
            :return:
            """
            return Error.OK, '', ''
    
        @classmethod
        def stop_container(cls, *_) -> Tuple[Error, str, str]:
            """
            Stop container started upon image name
            :param _:
            :return:
            """
            return Error.OK, '', ''
    
        @classmethod
        def delete_image(cls, *_) -> Tuple[Error, str, str]:
            """
            Delete image
            :param _:
            :return:
            """
            return Error.OK, '', ''
    
        @classmethod
        def install_github_service(cls, *_) -> Tuple[Error, str, str]:
            """
            Install github runner as a service
            :param _:
            :return:
            """
            return Error.OK, '', ''
    
        @classmethod
        def start_github_service(cls, *_) -> Tuple[Error, str, str]:
            """
            Start github runner service
            :param _:
            :return:
            """
            return Error.OK, '', ''
    
        @classmethod
        def stop_github_service(cls, *_) -> Tuple[Error, str, str]:
            """
            Stop github runner service
            :param _:
            :return:
            """
            return Error.OK, '', ''

## Classes

` class LocalClient `

    

Abstraction to represent local device

Expand source code

    
    
    class LocalClient:
        """
        Abstraction to represent local device
        """
    
        # @classmethod
        # def __container_running(cls, *_) -> bool:
        #     """
        #     Checks if docker container is already running
        #     :param image_name: Image name
        #     :return: True if docker container is running, False otherwise
        #     """
        #     return False
    
        @classmethod
        def build_docker_image(cls, *_) \
                -> Tuple[Error, str, str]:
            """
            Build docker image
            :param _:
            :return:
            """
            return Error.OK, '', ''
    
        @classmethod
        def start_container(cls, *_) -> Tuple[Error, str, str]:
            """
            Start docker container from image name
            :param _:
            :return:
            """
            return Error.OK, '', ''
    
        @classmethod
        def stop_container(cls, *_) -> Tuple[Error, str, str]:
            """
            Stop container started upon image name
            :param _:
            :return:
            """
            return Error.OK, '', ''
    
        @classmethod
        def delete_image(cls, *_) -> Tuple[Error, str, str]:
            """
            Delete image
            :param _:
            :return:
            """
            return Error.OK, '', ''
    
        @classmethod
        def install_github_service(cls, *_) -> Tuple[Error, str, str]:
            """
            Install github runner as a service
            :param _:
            :return:
            """
            return Error.OK, '', ''
    
        @classmethod
        def start_github_service(cls, *_) -> Tuple[Error, str, str]:
            """
            Start github runner service
            :param _:
            :return:
            """
            return Error.OK, '', ''
    
        @classmethod
        def stop_github_service(cls, *_) -> Tuple[Error, str, str]:
            """
            Stop github runner service
            :param _:
            :return:
            """
            return Error.OK, '', ''

### Static methods

` def build_docker_image(*_) ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str, str] `

    

Build docker image :param _: :return:

Expand source code

    
    
    @classmethod
    def build_docker_image(cls, *_) \
            -> Tuple[Error, str, str]:
        """
        Build docker image
        :param _:
        :return:
        """
        return Error.OK, '', ''

` def delete_image(*_) ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str, str] `

    

Delete image :param _: :return:

Expand source code

    
    
    @classmethod
    def delete_image(cls, *_) -> Tuple[Error, str, str]:
        """
        Delete image
        :param _:
        :return:
        """
        return Error.OK, '', ''

` def install_github_service(*_) ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str, str] `

    

Install github runner as a service :param _: :return:

Expand source code

    
    
    @classmethod
    def install_github_service(cls, *_) -> Tuple[Error, str, str]:
        """
        Install github runner as a service
        :param _:
        :return:
        """
        return Error.OK, '', ''

` def start_container(*_) ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str, str] `

    

Start docker container from image name :param _: :return:

Expand source code

    
    
    @classmethod
    def start_container(cls, *_) -> Tuple[Error, str, str]:
        """
        Start docker container from image name
        :param _:
        :return:
        """
        return Error.OK, '', ''

` def start_github_service(*_) ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str, str] `

    

Start github runner service :param _: :return:

Expand source code

    
    
    @classmethod
    def start_github_service(cls, *_) -> Tuple[Error, str, str]:
        """
        Start github runner service
        :param _:
        :return:
        """
        return Error.OK, '', ''

` def stop_container(*_) ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str, str] `

    

Stop container started upon image name :param _: :return:

Expand source code

    
    
    @classmethod
    def stop_container(cls, *_) -> Tuple[Error, str, str]:
        """
        Stop container started upon image name
        :param _:
        :return:
        """
        return Error.OK, '', ''

` def stop_github_service(*_) ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str, str] `

    

Stop github runner service :param _: :return:

Expand source code

    
    
    @classmethod
    def stop_github_service(cls, *_) -> Tuple[Error, str, str]:
        """
        Stop github runner service
        :param _:
        :return:
        """
        return Error.OK, '', ''

# Index

  * ### Super-module

    * `[app.device](index.html "app.device")`
  * ### Classes

    * #### `LocalClient`

      * `build_docker_image`
      * `delete_image`
      * `install_github_service`
      * `start_container`
      * `start_github_service`
      * `stop_container`
      * `stop_github_service`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.device.remote`

Remote device module

Expand source code

    
    
    """ Remote device module """
    import os
    from typing import Tuple
    import paramiko
    import scp
    from app.error.error import Error
    
    
    class RemoteClient:
        """
        RemoteClient
        """
        def __init__(self,
                     host: str = '',
                     user: str = '',
                     password: str = ''):
            """
            Remote device abstraction
            :param host: Host address/name
            :param user: User to log in
            :param password: User password
            """
            self.host = host
            self.user = user
            self.password = password
            self.ssh_client = paramiko.SSHClient()
            self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.ssh_client.connect(self.host, username=self.user, password=self.password, timeout=15)
            self.scp_client = scp.SCPClient(self.ssh_client.get_transport())
    
        def __del__(self):
            self.scp_client.close()
            self.ssh_client.close()
    
        def __container_running(self, image_name: str = '') -> bool:
            _, stdout, _ = self.ssh_client.exec_command(
                'docker ps -q  --filter ancestor=' + image_name)
            if stdout.channel.recv_exit_status() != 0:
                return False
            return stdout.read().decode("utf-8").strip('\n') != ''
    
        def build_docker_image(self,  # pylint: disable=too-many-arguments
                               docker_file_path: str = '',
                               github_user: str = '',
                               github_token: str = '',
                               repository_name: str = '',
                               image_name: str = '',
                               additional_linux_packages: str = '',
                               additional_python_packages: str = '')\
                -> Tuple[Error, str, str]:
            """
            Build docker image
            :param docker_file_path:
            :param github_user:
            :param github_token:
            :param repository_name:
            :param image_name:
            :param additional_linux_packages:
            :param additional_python_packages:
            :return:
            """
            self.scp_client.put(files=os.path.dirname(docker_file_path) + '/entrypoint.sh',
                                remote_path='/tmp/entrypoint.sh')
            self.scp_client.put(files=docker_file_path,
                                remote_path='/tmp/github-runner.dockerfile')
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo docker build -t ' + image_name + ' -f /tmp/github-runner.dockerfile' +
                ' --build-arg REPOSITORY=' + repository_name + ' --build-arg GITHUB_TOKEN=' +
                github_token + ' --build-arg GITHUB_USER=' + github_user +
                ' --build-arg ADDITIONAL_PACKAGES=' + additional_linux_packages +
                ' --build-arg ADDITIONAL_PYTHON_PACKAGES=' + additional_python_packages +
                ' --build-arg RUNNER_NAME=' + image_name + ' /tmp', get_pty=True)
            for line in iter(stdout.readline, ""):
                print(line, end="")
            return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR,\
                stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
    
        def start_container(self,
                            image_name: str = '') -> Tuple[Error, str, str]:
            """
            Start docker container upon image name
            :param image_name:
            :return:
            """
            if self.__container_running(image_name):
                return Error.ALREADY, '', ''
            run_command = 'sudo docker run -d --restart unless-stopped --network host '
            _, stdout, stderr = self.ssh_client.exec_command(run_command + image_name)
            return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
                stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
    
        def stop_container(self,
                           image_name: str = '') -> Tuple[Error, str, str]:
            """
            Stop docker container
            :param image_name:
            :return:
            """
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo docker ps -a -q  --filter ancestor=' + image_name)
            if stdout.channel.recv_exit_status() != 0:
                return Error.SSH_ERROR, stdout.read().decode("utf-8"), \
                       stderr.read().decode("utf-8")
            container_names = stdout.read().decode("utf-8").split('\n')
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo docker update --restart no ' + ' '.join(container_names))
            if stdout.channel.recv_exit_status() != 0:
                return Error.SSH_ERROR, stdout.read().decode("utf-8"),\
                    stderr.read().decode("utf-8")
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo docker stop ' + ' '.join(container_names))
            return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
                stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
    
        def delete_image(self,
                         image_name: str = '') -> Tuple[Error, str, str]:
            """
            Delete docker image
            :param image_name:
            :return:
            """
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo docker image rm ' + image_name, get_pty=True)
            for line in iter(stdout.readline, ""):
                print(line, end="")
            return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
                stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
    
        def install_github_service(self,  # pylint: disable=too-many-arguments
                                   github_user: str = '',
                                   github_token: str = '',
                                   repository_name: str = '',
                                   runner_name: str = '',
                                   dest_dir: str = '/home/github-runner') -> Tuple[Error, str, str]:
            """
            Install github runner service
            :param github_user:
            :param github_token:
            :param repository_name:
            :param runner_name:
            :param dest_dir:
            :return:
            """
            architectures = {
                "amd64": "x64",
                "arm64": "arm64",
                "arm": "arm"
            }
            _, stdout, stderr = self.ssh_client.exec_command('dpkg --print-architecture')
            if stdout.channel.recv_exit_status() != 0:
                return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
            arch = architectures[stdout.read().decode("utf-8").strip('\n')]
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo mkdir -p ' + dest_dir + '/' + runner_name)
            if stdout.channel.recv_exit_status() != 0:
                return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo curl -o ' + dest_dir + '/' + runner_name + '/actions-runner-linux-' +
                arch + '-2.296.1.tar.gz -L ' +
                '"https://github.com/actions/runner/releases/download/v2.296.1/actions-runner-linux-' +
                arch + '-2.296.1.tar.gz"', get_pty=True)
            for line in iter(stdout.readline, ""):
                print(line, end="")
            if stdout.channel.recv_exit_status() != 0:
                return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo tar xzf ' + dest_dir + '/' + runner_name + '/actions-runner-linux-' +
                arch + '-2.296.1.tar.gz -C ' + dest_dir, get_pty=True)
            for line in iter(stdout.readline, ""):
                print(line, end="")
            if stdout.channel.recv_exit_status() != 0:
                return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo ' + dest_dir + '/' + runner_name + '/bin/installdependencies.sh', get_pty=True)
            for line in iter(stdout.readline, ""):
                print(line, end="")
            if stdout.channel.recv_exit_status() != 0:
                return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo RUNNER_ALLOW_RUNASROOT="1" ' + dest_dir + '/' +
                runner_name + './config.sh --unattended --url "https://github.com/' +
                github_user + '/' + repository_name + '" --token "' +
                github_token + '" --name "' + runner_name +
                '" --labels "shell_service"', get_pty=True)
            for line in iter(stdout.readline, ""):
                print(line, end="")
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo RUNNER_ALLOW_RUNASROOT="1" ' + dest_dir + '/' +
                runner_name + './svc.sh install', get_pty=True)
            for line in iter(stdout.readline, ""):
                print(line, end="")
            return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
                stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
    
        def start_github_service(self,
                                 runner_name: str = '',
                                 service_dir: str = '/home/github-runner') -> Tuple[Error, str, str]:
            """
            Start github runner service
            :param runner_name:
            :param service_dir:
            :return:
            """
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo ' + service_dir + '/' + runner_name + '/svc.sh start')
            return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
                stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
    
        def stop_github_service(self,
                                runner_name: str = '',
                                service_dir: str = '/home/github-runner') -> Tuple[Error, str, str]:
            """
            Stop github runner service
            :param runner_name:
            :param service_dir:
            :return:
            """
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo ' + service_dir + '/' + runner_name + '/svc.sh stop')
            return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
                stdout.read().decode("utf-8"), stderr.read().decode("utf-8")

## Classes

` class RemoteClient (host: str = '', user: str = '', password: str = '') `

    

RemoteClient

Remote device abstraction :param host: Host address/name :param user: User to
log in :param password: User password

Expand source code

    
    
    class RemoteClient:
        """
        RemoteClient
        """
        def __init__(self,
                     host: str = '',
                     user: str = '',
                     password: str = ''):
            """
            Remote device abstraction
            :param host: Host address/name
            :param user: User to log in
            :param password: User password
            """
            self.host = host
            self.user = user
            self.password = password
            self.ssh_client = paramiko.SSHClient()
            self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.ssh_client.connect(self.host, username=self.user, password=self.password, timeout=15)
            self.scp_client = scp.SCPClient(self.ssh_client.get_transport())
    
        def __del__(self):
            self.scp_client.close()
            self.ssh_client.close()
    
        def __container_running(self, image_name: str = '') -> bool:
            _, stdout, _ = self.ssh_client.exec_command(
                'docker ps -q  --filter ancestor=' + image_name)
            if stdout.channel.recv_exit_status() != 0:
                return False
            return stdout.read().decode("utf-8").strip('\n') != ''
    
        def build_docker_image(self,  # pylint: disable=too-many-arguments
                               docker_file_path: str = '',
                               github_user: str = '',
                               github_token: str = '',
                               repository_name: str = '',
                               image_name: str = '',
                               additional_linux_packages: str = '',
                               additional_python_packages: str = '')\
                -> Tuple[Error, str, str]:
            """
            Build docker image
            :param docker_file_path:
            :param github_user:
            :param github_token:
            :param repository_name:
            :param image_name:
            :param additional_linux_packages:
            :param additional_python_packages:
            :return:
            """
            self.scp_client.put(files=os.path.dirname(docker_file_path) + '/entrypoint.sh',
                                remote_path='/tmp/entrypoint.sh')
            self.scp_client.put(files=docker_file_path,
                                remote_path='/tmp/github-runner.dockerfile')
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo docker build -t ' + image_name + ' -f /tmp/github-runner.dockerfile' +
                ' --build-arg REPOSITORY=' + repository_name + ' --build-arg GITHUB_TOKEN=' +
                github_token + ' --build-arg GITHUB_USER=' + github_user +
                ' --build-arg ADDITIONAL_PACKAGES=' + additional_linux_packages +
                ' --build-arg ADDITIONAL_PYTHON_PACKAGES=' + additional_python_packages +
                ' --build-arg RUNNER_NAME=' + image_name + ' /tmp', get_pty=True)
            for line in iter(stdout.readline, ""):
                print(line, end="")
            return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR,\
                stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
    
        def start_container(self,
                            image_name: str = '') -> Tuple[Error, str, str]:
            """
            Start docker container upon image name
            :param image_name:
            :return:
            """
            if self.__container_running(image_name):
                return Error.ALREADY, '', ''
            run_command = 'sudo docker run -d --restart unless-stopped --network host '
            _, stdout, stderr = self.ssh_client.exec_command(run_command + image_name)
            return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
                stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
    
        def stop_container(self,
                           image_name: str = '') -> Tuple[Error, str, str]:
            """
            Stop docker container
            :param image_name:
            :return:
            """
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo docker ps -a -q  --filter ancestor=' + image_name)
            if stdout.channel.recv_exit_status() != 0:
                return Error.SSH_ERROR, stdout.read().decode("utf-8"), \
                       stderr.read().decode("utf-8")
            container_names = stdout.read().decode("utf-8").split('\n')
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo docker update --restart no ' + ' '.join(container_names))
            if stdout.channel.recv_exit_status() != 0:
                return Error.SSH_ERROR, stdout.read().decode("utf-8"),\
                    stderr.read().decode("utf-8")
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo docker stop ' + ' '.join(container_names))
            return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
                stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
    
        def delete_image(self,
                         image_name: str = '') -> Tuple[Error, str, str]:
            """
            Delete docker image
            :param image_name:
            :return:
            """
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo docker image rm ' + image_name, get_pty=True)
            for line in iter(stdout.readline, ""):
                print(line, end="")
            return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
                stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
    
        def install_github_service(self,  # pylint: disable=too-many-arguments
                                   github_user: str = '',
                                   github_token: str = '',
                                   repository_name: str = '',
                                   runner_name: str = '',
                                   dest_dir: str = '/home/github-runner') -> Tuple[Error, str, str]:
            """
            Install github runner service
            :param github_user:
            :param github_token:
            :param repository_name:
            :param runner_name:
            :param dest_dir:
            :return:
            """
            architectures = {
                "amd64": "x64",
                "arm64": "arm64",
                "arm": "arm"
            }
            _, stdout, stderr = self.ssh_client.exec_command('dpkg --print-architecture')
            if stdout.channel.recv_exit_status() != 0:
                return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
            arch = architectures[stdout.read().decode("utf-8").strip('\n')]
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo mkdir -p ' + dest_dir + '/' + runner_name)
            if stdout.channel.recv_exit_status() != 0:
                return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo curl -o ' + dest_dir + '/' + runner_name + '/actions-runner-linux-' +
                arch + '-2.296.1.tar.gz -L ' +
                '"https://github.com/actions/runner/releases/download/v2.296.1/actions-runner-linux-' +
                arch + '-2.296.1.tar.gz"', get_pty=True)
            for line in iter(stdout.readline, ""):
                print(line, end="")
            if stdout.channel.recv_exit_status() != 0:
                return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo tar xzf ' + dest_dir + '/' + runner_name + '/actions-runner-linux-' +
                arch + '-2.296.1.tar.gz -C ' + dest_dir, get_pty=True)
            for line in iter(stdout.readline, ""):
                print(line, end="")
            if stdout.channel.recv_exit_status() != 0:
                return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo ' + dest_dir + '/' + runner_name + '/bin/installdependencies.sh', get_pty=True)
            for line in iter(stdout.readline, ""):
                print(line, end="")
            if stdout.channel.recv_exit_status() != 0:
                return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo RUNNER_ALLOW_RUNASROOT="1" ' + dest_dir + '/' +
                runner_name + './config.sh --unattended --url "https://github.com/' +
                github_user + '/' + repository_name + '" --token "' +
                github_token + '" --name "' + runner_name +
                '" --labels "shell_service"', get_pty=True)
            for line in iter(stdout.readline, ""):
                print(line, end="")
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo RUNNER_ALLOW_RUNASROOT="1" ' + dest_dir + '/' +
                runner_name + './svc.sh install', get_pty=True)
            for line in iter(stdout.readline, ""):
                print(line, end="")
            return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
                stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
    
        def start_github_service(self,
                                 runner_name: str = '',
                                 service_dir: str = '/home/github-runner') -> Tuple[Error, str, str]:
            """
            Start github runner service
            :param runner_name:
            :param service_dir:
            :return:
            """
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo ' + service_dir + '/' + runner_name + '/svc.sh start')
            return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
                stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
    
        def stop_github_service(self,
                                runner_name: str = '',
                                service_dir: str = '/home/github-runner') -> Tuple[Error, str, str]:
            """
            Stop github runner service
            :param runner_name:
            :param service_dir:
            :return:
            """
            _, stdout, stderr = self.ssh_client.exec_command(
                'sudo ' + service_dir + '/' + runner_name + '/svc.sh stop')
            return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
                stdout.read().decode("utf-8"), stderr.read().decode("utf-8")

### Methods

` def build_docker_image(self, docker_file_path: str = '', github_user: str =
'', github_token: str = '', repository_name: str = '', image_name: str = '',
additional_linux_packages: str = '', additional_python_packages: str = '') ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str, str] `

    

Build docker image :param docker_file_path: :param github_user: :param
github_token: :param repository_name: :param image_name: :param
additional_linux_packages: :param additional_python_packages: :return:

Expand source code

    
    
    def build_docker_image(self,  # pylint: disable=too-many-arguments
                           docker_file_path: str = '',
                           github_user: str = '',
                           github_token: str = '',
                           repository_name: str = '',
                           image_name: str = '',
                           additional_linux_packages: str = '',
                           additional_python_packages: str = '')\
            -> Tuple[Error, str, str]:
        """
        Build docker image
        :param docker_file_path:
        :param github_user:
        :param github_token:
        :param repository_name:
        :param image_name:
        :param additional_linux_packages:
        :param additional_python_packages:
        :return:
        """
        self.scp_client.put(files=os.path.dirname(docker_file_path) + '/entrypoint.sh',
                            remote_path='/tmp/entrypoint.sh')
        self.scp_client.put(files=docker_file_path,
                            remote_path='/tmp/github-runner.dockerfile')
        _, stdout, stderr = self.ssh_client.exec_command(
            'sudo docker build -t ' + image_name + ' -f /tmp/github-runner.dockerfile' +
            ' --build-arg REPOSITORY=' + repository_name + ' --build-arg GITHUB_TOKEN=' +
            github_token + ' --build-arg GITHUB_USER=' + github_user +
            ' --build-arg ADDITIONAL_PACKAGES=' + additional_linux_packages +
            ' --build-arg ADDITIONAL_PYTHON_PACKAGES=' + additional_python_packages +
            ' --build-arg RUNNER_NAME=' + image_name + ' /tmp', get_pty=True)
        for line in iter(stdout.readline, ""):
            print(line, end="")
        return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR,\
            stdout.read().decode("utf-8"), stderr.read().decode("utf-8")

` def delete_image(self, image_name: str = '') ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str, str] `

    

Delete docker image :param image_name: :return:

Expand source code

    
    
    def delete_image(self,
                     image_name: str = '') -> Tuple[Error, str, str]:
        """
        Delete docker image
        :param image_name:
        :return:
        """
        _, stdout, stderr = self.ssh_client.exec_command(
            'sudo docker image rm ' + image_name, get_pty=True)
        for line in iter(stdout.readline, ""):
            print(line, end="")
        return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
            stdout.read().decode("utf-8"), stderr.read().decode("utf-8")

` def install_github_service(self, github_user: str = '', github_token: str =
'', repository_name: str = '', runner_name: str = '', dest_dir: str =
'/home/github-runner') ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str, str] `

    

Install github runner service :param github_user: :param github_token: :param
repository_name: :param runner_name: :param dest_dir: :return:

Expand source code

    
    
    def install_github_service(self,  # pylint: disable=too-many-arguments
                               github_user: str = '',
                               github_token: str = '',
                               repository_name: str = '',
                               runner_name: str = '',
                               dest_dir: str = '/home/github-runner') -> Tuple[Error, str, str]:
        """
        Install github runner service
        :param github_user:
        :param github_token:
        :param repository_name:
        :param runner_name:
        :param dest_dir:
        :return:
        """
        architectures = {
            "amd64": "x64",
            "arm64": "arm64",
            "arm": "arm"
        }
        _, stdout, stderr = self.ssh_client.exec_command('dpkg --print-architecture')
        if stdout.channel.recv_exit_status() != 0:
            return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
        arch = architectures[stdout.read().decode("utf-8").strip('\n')]
        _, stdout, stderr = self.ssh_client.exec_command(
            'sudo mkdir -p ' + dest_dir + '/' + runner_name)
        if stdout.channel.recv_exit_status() != 0:
            return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
        _, stdout, stderr = self.ssh_client.exec_command(
            'sudo curl -o ' + dest_dir + '/' + runner_name + '/actions-runner-linux-' +
            arch + '-2.296.1.tar.gz -L ' +
            '"https://github.com/actions/runner/releases/download/v2.296.1/actions-runner-linux-' +
            arch + '-2.296.1.tar.gz"', get_pty=True)
        for line in iter(stdout.readline, ""):
            print(line, end="")
        if stdout.channel.recv_exit_status() != 0:
            return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
        _, stdout, stderr = self.ssh_client.exec_command(
            'sudo tar xzf ' + dest_dir + '/' + runner_name + '/actions-runner-linux-' +
            arch + '-2.296.1.tar.gz -C ' + dest_dir, get_pty=True)
        for line in iter(stdout.readline, ""):
            print(line, end="")
        if stdout.channel.recv_exit_status() != 0:
            return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
        _, stdout, stderr = self.ssh_client.exec_command(
            'sudo ' + dest_dir + '/' + runner_name + '/bin/installdependencies.sh', get_pty=True)
        for line in iter(stdout.readline, ""):
            print(line, end="")
        if stdout.channel.recv_exit_status() != 0:
            return Error.SSH_ERROR, stdout.read().decode("utf-8"), stderr.read().decode("utf-8")
        _, stdout, stderr = self.ssh_client.exec_command(
            'sudo RUNNER_ALLOW_RUNASROOT="1" ' + dest_dir + '/' +
            runner_name + './config.sh --unattended --url "https://github.com/' +
            github_user + '/' + repository_name + '" --token "' +
            github_token + '" --name "' + runner_name +
            '" --labels "shell_service"', get_pty=True)
        for line in iter(stdout.readline, ""):
            print(line, end="")
        _, stdout, stderr = self.ssh_client.exec_command(
            'sudo RUNNER_ALLOW_RUNASROOT="1" ' + dest_dir + '/' +
            runner_name + './svc.sh install', get_pty=True)
        for line in iter(stdout.readline, ""):
            print(line, end="")
        return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
            stdout.read().decode("utf-8"), stderr.read().decode("utf-8")

` def start_container(self, image_name: str = '') ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str, str] `

    

Start docker container upon image name :param image_name: :return:

Expand source code

    
    
    def start_container(self,
                        image_name: str = '') -> Tuple[Error, str, str]:
        """
        Start docker container upon image name
        :param image_name:
        :return:
        """
        if self.__container_running(image_name):
            return Error.ALREADY, '', ''
        run_command = 'sudo docker run -d --restart unless-stopped --network host '
        _, stdout, stderr = self.ssh_client.exec_command(run_command + image_name)
        return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
            stdout.read().decode("utf-8"), stderr.read().decode("utf-8")

` def start_github_service(self, runner_name: str = '', service_dir: str =
'/home/github-runner') ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str, str] `

    

Start github runner service :param runner_name: :param service_dir: :return:

Expand source code

    
    
    def start_github_service(self,
                             runner_name: str = '',
                             service_dir: str = '/home/github-runner') -> Tuple[Error, str, str]:
        """
        Start github runner service
        :param runner_name:
        :param service_dir:
        :return:
        """
        _, stdout, stderr = self.ssh_client.exec_command(
            'sudo ' + service_dir + '/' + runner_name + '/svc.sh start')
        return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
            stdout.read().decode("utf-8"), stderr.read().decode("utf-8")

` def stop_container(self, image_name: str = '') ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str, str] `

    

Stop docker container :param image_name: :return:

Expand source code

    
    
    def stop_container(self,
                       image_name: str = '') -> Tuple[Error, str, str]:
        """
        Stop docker container
        :param image_name:
        :return:
        """
        _, stdout, stderr = self.ssh_client.exec_command(
            'sudo docker ps -a -q  --filter ancestor=' + image_name)
        if stdout.channel.recv_exit_status() != 0:
            return Error.SSH_ERROR, stdout.read().decode("utf-8"), \
                   stderr.read().decode("utf-8")
        container_names = stdout.read().decode("utf-8").split('\n')
        _, stdout, stderr = self.ssh_client.exec_command(
            'sudo docker update --restart no ' + ' '.join(container_names))
        if stdout.channel.recv_exit_status() != 0:
            return Error.SSH_ERROR, stdout.read().decode("utf-8"),\
                stderr.read().decode("utf-8")
        _, stdout, stderr = self.ssh_client.exec_command(
            'sudo docker stop ' + ' '.join(container_names))
        return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
            stdout.read().decode("utf-8"), stderr.read().decode("utf-8")

` def stop_github_service(self, runner_name: str = '', service_dir: str =
'/home/github-runner') ‑>
Tuple[[Error](../error/error.html#app.error.error.Error
"app.error.error.Error"), str, str] `

    

Stop github runner service :param runner_name: :param service_dir: :return:

Expand source code

    
    
    def stop_github_service(self,
                            runner_name: str = '',
                            service_dir: str = '/home/github-runner') -> Tuple[Error, str, str]:
        """
        Stop github runner service
        :param runner_name:
        :param service_dir:
        :return:
        """
        _, stdout, stderr = self.ssh_client.exec_command(
            'sudo ' + service_dir + '/' + runner_name + '/svc.sh stop')
        return Error.OK if stdout.channel.recv_exit_status() == 0 else Error.SSH_ERROR, \
            stdout.read().decode("utf-8"), stderr.read().decode("utf-8")

# Index

  * ### Super-module

    * `[app.device](index.html "app.device")`
  * ### Classes

    * #### `RemoteClient`

      * `build_docker_image`
      * `delete_image`
      * `install_github_service`
      * `start_container`
      * `start_github_service`
      * `stop_container`
      * `stop_github_service`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.error`

## Sub-modules

`[app.error.error](error.html "app.error.error")`

    

Error module. Provides all error codes and message casting

# Index

  * ### Super-module

    * `[app](../index.html "app")`
  * ### Sub-modules

    * `[app.error.error](error.html "app.error.error")`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

# Module `app.error.error`

Error module. Provides all error codes and message casting

Expand source code

    
    
    """ Error module. Provides all error codes and message casting """
    from enum import Enum
    
    
    class Error(Enum):
        """
        Error codes used in PyGrm
        """
        OK = 0
        PARSE_ERROR = 1
        HTTP_ERROR = 2
        EMPTY = 3
        VALUE_ERROR = 4
        SSH_ERROR = 5
        ALREADY = 6
    
    
    _MESSAGES = {
        Error.OK: 'Ok',
        Error.PARSE_ERROR: 'Parse error',
        Error.HTTP_ERROR: 'HTTP error',
        Error.EMPTY: 'Empty value',
        Error.VALUE_ERROR: 'Wrong value',
        Error.SSH_ERROR: 'SSH error',
        Error.ALREADY: 'Already existing / running'
    }
    
    
    def message(error: Error = None) -> str:
        """
        Casts error codes to description message
        :param error: Error code
        :return: Description message
        """
        for error_code, description in _MESSAGES.items():
            if error_code == error:
                return description
        return 'Unknown error'

## Functions

` def message(error: Error = None) ‑> str `

    

Casts error codes to description message :param error: Error code :return:
Description message

Expand source code

    
    
    def message(error: Error = None) -> str:
        """
        Casts error codes to description message
        :param error: Error code
        :return: Description message
        """
        for error_code, description in _MESSAGES.items():
            if error_code == error:
                return description
        return 'Unknown error'

## Classes

` class Error (value, names=None, *, module=None, qualname=None, type=None,
start=1) `

    

Error codes used in PyGrm

Expand source code

    
    
    class Error(Enum):
        """
        Error codes used in PyGrm
        """
        OK = 0
        PARSE_ERROR = 1
        HTTP_ERROR = 2
        EMPTY = 3
        VALUE_ERROR = 4
        SSH_ERROR = 5
        ALREADY = 6

### Ancestors

  * enum.Enum

### Class variables

`var ALREADY`

    

`var EMPTY`

    

`var HTTP_ERROR`

    

`var OK`

    

`var PARSE_ERROR`

    

`var SSH_ERROR`

    

`var VALUE_ERROR`

    

# Index

  * ### Super-module

    * `[app.error](index.html "app.error")`
  * ### Functions

    * `message`
  * ### Classes

    * #### `Error`

      * `ALREADY`
      * `EMPTY`
      * `HTTP_ERROR`
      * `OK`
      * `PARSE_ERROR`
      * `SSH_ERROR`
      * `VALUE_ERROR`

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

